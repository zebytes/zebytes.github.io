[{"title":"类加载—双亲委派机制","url":"/2025/06/17/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E2%80%94%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/","content":"\n先说说什么是类加载器\n类加载器是Java虚拟机提供给应用程序去实现和获取类和接口字节码的技术，用于动态加载Java类到内存中(将字节码转换为byte[ ])的组件\n\n四种类加载器\n启动类加载器(Bootstrap ClassLoader)，加载核心类，比如String类\n扩展类加载器(Extension ClassLoader)，加载扩展类\n应用程序类加载器(Application ClassLoader)，加载classpath中的类\n自定义类加载器，一般重写findClass方法\n\n\n注: JDK9之后扩展类加载器 (Extension ClassLoader) 变为平台类加载器 (Platform ClassLoader)\n\n\n什么是双亲委派机制\n每个Java实现的类加载器中都有一个属性，可以理解为存放的是其父类加载器\n![[无标题.png]]\n\n\n\n启动类加载器是用本地代码，通常是C&#x2F;C++写的，所以用java代码不能获取，结果返回为null，所以扩展类的parent属性是null，但是逻辑上来说启动类加载器还是相当于它的父类JDK9引入了module的概念，类加载器在设计上发生很大改变，启动类加载器使用java编写，不过仍然无法通过java代码获取到，返回依然是null\n\n\n自底向上进行查找： 如果类没有被当前加载器加载过，则查找父类有没有加载过，如果加载过则返回，如果没有则继续向上查找\n由顶向下进行加载： 如果直到启动类加载器都没有被加载过，则由父类尝试加载，再由子类尝试，直到被加载并返回\n\n双亲委派机制的好处\n防止类的重复加载 ：通过双亲委派机制，每个类加载器在加载类时都会委派给其父加载器，因此可以避免同一个类被多个加载器加载，保证了类的唯一性\n保护类的安全性 ：双亲委派机制可以防止恶意类的加载，即使是恶意类也无法绕过双亲委派机制直接被加载，它们必须被放置在被信任的类路径下才能被加载\n保护核心类库的完整性 ：通过双亲委派机制，Java核心类库（如java.lang包）被放置在引导类加载器的类路径下，这样可以保护核心类库的完整性，防止被篡改或替换，确保了Java运行环境的稳定性和安全性\n\n\n源码简单分析ClassLoader中有几个重要方法\n类加载的入口，提供双亲委派机制，内部调用findClass  \nloadClass(String):Class&lt;?&gt; \n 类加载器子类实现，获取二进制数据调用defineClass\n  findClass(String):Class&lt;?&gt; \n做类名校验，调用虚拟机底层方法将字节码加载到内存\ndefineClass(String, byte[], int, int):Class&lt;?&gt; \n执行类生命周期连接阶段\nresolveClass(Class&lt;?&gt;):void \n\n//1.String name 被加载类名protected Class&lt;?&gt; loadClass(String name, boolean resolve)      throws ClassNotFoundException  &#123;      //2，加锁防止在多线程条件下重复加载类    synchronized (getClassLoadingLock(name))     &#123;          //3，查找此类是否被加载过，若被加载则返回Class对象        Class&lt;?&gt; c = findLoadedClass(name);          //4，如果c为空，则说明未被加载过，否则，是被加载过，跳到10        if (c == null) &#123;              long t0 = System.nanoTime();              try &#123;                  //5，判断父类加载器是否为null                if (parent != null) &#123;                    //6，如果不为空，则调用父类loadClass方法                      c = parent.loadClass(name, false);                  &#125;                 else &#123;                      //7，如果为空，说明父类为启动类加载器，调用本地方法来加载                    c = findBootstrapClassOrNull(name);                  &#125;              &#125;             catch (ClassNotFoundException e) &#123;              &#125;              //8，如果c为空，说明其父类都没有加载成功，则由当前类加载器来进行加载            if (c == null) &#123;                        //9，加载类                  c = findClass(name);                                  PerfCounter.getParentDelegationTime().addTime(t1 - t0);                  PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                  PerfCounter.getFindClasses().increment();              &#125;          &#125;                  if (resolve) &#123;              resolveClass(c);          &#125;                  //10，返回Class对象        return c;      &#125;  &#125;\n\n\n打破双亲委派机制\n自定义类加载器，重写loadClass方法，不再实现双亲委派机制\nJNDI，JDBC，JCE，JAXB 和 JBI 等框架使用了SPI机制+线程上下文类加载器\nOSGI 允许同级类加载器相互调用\n\n","categories":["JVM"],"tags":["类加载"]},{"title":"Docker配置Prometheus+Grafana监控，AlertManager告警通知","url":"/2025/06/18/Docker%E9%85%8D%E7%BD%AEPrometheus+Grafana%E7%9B%91%E6%8E%A7%EF%BC%8CAlertManager%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/","content":"环境虚拟机 centos 7 ip : 192.168.37.200所有镜像都是官方镜像 版本：latestprometheus 3.4.1grafana v12.0.1alertmanager 0.28.1\n创建Prometheus容器创建配置文件选择目录创建prometheus.yml，是prometheus的配置文件，等下挂载它，内容如下\nglobal:  scrape_interval: 15s   evaluation_interval: 15salerting:  alertmanagers:    - static_configs:        - targets:            #- &quot;192.168.37.200:9103&quot;rule_files:    # - &quot;first_rules.yml&quot;  # - &quot;second_rules.yml&quot;scrape_configs:  - job_name: &quot;prometheus&quot;    static_configs:      - targets: [&quot;localhost:9090&quot;]         \n\n创建告警规则目录（不需要告警可以忽略这一步）选择目录创建一个告警规则的文件夹用来放告警的规则，比如\n\n启动prometheus启动prometheus，如果不需要告警可以不挂载告警规则对应文件夹\ndocker run --name prometheus -d  --user root \\-p 9100:9090 \\ --restart=always \\-v ./WangZe/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \\-v ./WangZe/prometheus/prometheusAlertRules/:/root/prometheusRules/ \\prom/prometheus\n\n\n容器创建成功后，即可通过浏览器访问 http://192.168.37.200:9100 可看到Prometheus默认的UI界面\n\n创建Grafana容器Grafana是一个跨平台开源的度量分析和可视化工具，可以通过将采集的数据可视化的展示\ndocker run -d --name=grafana --user root\\-p 9101:3000 \\-v ./WangZe/grafana/:/var/lib/grafana/ \\grafana/grafana\n\n-v ./WangZe/grafana/:/var/lib/grafana/ 是用于持久化 Grafana 的数据文件：Grafana 在运行时会生成各种数据，比如用户配置、仪表盘、插件数据等\n\n容器创建成功后，即可通过浏览器访问 http://192.168.37.200:9101 可看到Grafana界面\n\n监控Linux安装Node_exporter因为Prometheus 本身不具备监控功能，所以想要通过Prometheus 收集数据的话，需要安装对应的exporter\nExporter 的核心功能是采集数据并格式化，使其可以被 Prometheus 等监控工具使用\ndocker run -d --name=node-exporter \\--restart=always \\-p 9102:9100 \\-v &quot;/proc:/host/proc:ro&quot; \\-v &quot;/sys:/host/sys:ro&quot; \\-v &quot;/:/rootfs:ro&quot; \\prom/node-exporter\n\n挂载的路径是linux内部硬件、内存等信息的路径（好像也可以不用显示挂载，它可能默认挂载）\n\n容器创建成功后，即可通过浏览器访问 http://192.168.37.200:9102/metrics 来验证查看监控收集的数据\n\n配置 Prometheus 监控Node节点修改Prometheus主配置文件，在prometheus.tml配置文件按以下内容修改：\nscrape_configs:  - job_name: &quot;prometheus&quot;    # metrics_path defaults to &#x27;/metrics&#x27;    # scheme defaults to &#x27;http&#x27;.    static_configs:      - targets: [&quot;localhost:9090&quot;]      ##########################新增部分###########################  - job_name: &quot;linux&quot;                     #任务名称随便填了    static_configs:    - targets: [&#x27;192.168.37.200:9102&#x27;]    #node-exporter的地址      labels:        instance: local-centos##########################新增部分###########################\n\n重启Prometheus容器\ndocker restart prometheus\n\n访问prometheus然后能在对应页面看到对应的配置\n\n配置Grafana可视化界面页面可能由于版本，镜像源不同导致页面不一样，可能也就是按钮不一样吧，大概找找就行\n配置数据源\n\nName可以随便写、或者默认，然后填一个Prometheus的URL就好\n\n新建仪表盘\n\n可以去 https://grafana.com/grafana/dashboards/ 找想用的仪表盘\n比如这个是Linux的\n\n输入id然后加载\n最后选择一下数据源就好了\n找到刚刚的仪表盘即可看到对应的数据\n监控多个Linux也可以在前面基础上再加一个\n  - job_name: &quot;linux&quot;    static_configs:    - targets: [&#x27;192.168.37.200:9102&#x27;]      labels:        instance: local-centos############更改部分##############    - targets: [&#x27;--.--.--.--:----&#x27;]               labels:        instance: linux2  \n\n对应的效果就是这样，他们属于同一个Job，但是有两个实例\n监控Redis安装Redis_exporterdocker run -d --name redis-exporter -p 9093:9121 oliver006/redis_exporter --redis.addr redis://39.102.215.159:6379 --redis.password &#x27;yourpassword&#x27;\n\n配置 Prometheus 监控Node节点修改prometheus.yml文件\n- job_name: &#x27;redis-exporter&#x27;  static_configs:    - targets: [&#x27;192.168.37.200:9093&#x27;]      labels:        instance: redis-prod-1  # 建议改为实际Redis实例名称\n\n重启Prometheus\ndocker restart prometheus\n\n配置告警创建Alertmanager容器创建配置文件,配置邮件告警AlertManager 默认配置文件为 alertmanager.yml，QQ邮箱实例\n# 全局配置部分global:  # 解析超时时间设置为5分钟  resolve_timeout: 5m  # SMTP 发件人邮箱地址  smtp_from: &#x27;发件人邮箱地址&#x27;  # SMTP 服务器地址和端口 (QQ邮箱的SMTP服务器)  smtp_smarthost: &#x27;smtp.qq.com:465&#x27;  # SMTP 认证用户名 (通常与发件人邮箱相同)  smtp_auth_username: &#x27;2258702249@qq.com&#x27;  # SMTP 认证密码 (通常是QQ邮箱的授权码，而非登录密码)  smtp_auth_password: &#x27;QQ邮箱的授权码&#x27;  # 是否要求TLS加密连接，这里设置为false表示不强制要求  smtp_require_tls: false  # HELO/EHLO命令发送的域名，通常设置为SMTP服务器域名  smtp_hello: &#x27;qq.com&#x27;# 警报路由配置部分route:  # 按警报名称分组  group_by: [&#x27;alertname&#x27;]  # 分组等待时间：5秒，即等待5秒看是否有相同group_by字段的警报  group_wait: 10s  # 分组间隔时间：5秒，即每5秒检查一次是否有新的同组警报  group_interval: 5s  # 重复通知间隔：5分钟，即警报解决后5分钟内不会再次发送已解决通知  repeat_interval: 5m  # 该路由规则匹配的警报将发送到名为&#x27;email&#x27;的接收器  receiver: &#x27;email&#x27;# 接收器配置部分receivers:- name: &#x27;email&#x27;  # 接收器名称  email_configs:  - to: &#x27;收件人邮箱地址&#x27;  # 收件人邮箱地址    # 是否发送警报已解决的通知，这里设置为true表示会发送    send_resolved: true# 警报抑制规则部分inhibit_rules:  - source_match:      severity: &#x27;critical&#x27;  # 当存在严重级别为&#x27;critical&#x27;的警报时    target_match:      severity: &#x27;warning&#x27;   # 抑制严重级别为&#x27;warning&#x27;的警报    equal: [&#x27;alertname&#x27;, &#x27;dev&#x27;, &#x27;instance&#x27;]  # 只有当警报名称、dev和instance标签完全相同时才应用抑制规则\n\n启动Alertmanager在容器内路径为 /etc/alertmanager/alertmanager.yml\ndocker run -d --name alertmanager -p 9103:9093 \\-v ./WangZe/prometheus/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml \\prom/alertmanager\n\n配置Prometheus告警添加规则在之前的告警规则目录中创建规则文件，我用的是 .yml 格式，.rules 好像也可以\n然后重启容器\ndocker restart alertmanager\n\n修改配置文件然后修改prometheus.yml文件\nglobal:  scrape_interval: 15s  evaluation_interval: 15s   alerting:  alertmanagers:    - static_configs:        - targets:            - &quot;192.168.37.200:9103&quot;   #####配置为刚刚的Alertmanager地址# rule_files:  - &quot;/root/prometheusRules/*.yml&quot;    ####配置为刚刚设置的容器内部的放规则文件的路径\n\n记得重启容器，然后可以看到Prometheus控制台出现了对应规则\ndocker restart prometheus\n\n","categories":["配置"],"tags":["监控"]},{"title":"自定义spring boot starter组件","url":"/2025/06/19/%E8%87%AA%E5%AE%9A%E4%B9%89spring%20boot%20starter%E7%BB%84%E4%BB%B6/","content":"环境Springboot 3.0.2\n而且版本不同，META-INF目录下的内容可能不同，先记着**META-INF**下可能不一样，看到下面就知道了\n\n\nSpring Boot 2.6- META-INF&#x2F;spring.factories\n\nSpring Boot 2.7+ 上下两种都兼容\n\nSpring Boot 3.0+ META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports\n\n\n\nMETA-INF&#x2F;spring.factories的内容格式如下\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.ze.test.config.UserAutoConfiguration\n\nMETA-INF&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports的内容格式如下\ncom.ze.test.config.UserAutoConfiguration\n\n创建starter模块创建一个子模块\n添加所需依赖在子模块pom文件加一下依赖（父模块已经做了依赖版本管理了）\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n创建config包在子模块创建一个config包，用来存放自动配置类\n\n实现自动配置创建User类，UserAutoConfiguration类比如说我们可以放一个User类，然后写一个它的自动配置类\nUser类如下\npackage com.ze.test.user;public class User &#123;    private String name;    public User() &#123;    &#125;    public User(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;&#125;\n\nUserAutoConfiguration类如下\npackage com.ze.test.config;import com.ze.test.user.User;import org.springframework.boot.autoconfigure.AutoConfiguration;import org.springframework.context.annotation.Bean;@AutoConfigurationpublic class UserAutoConfiguration &#123;    @Bean    public User supplyUser() &#123;        return new User(&quot;自动配置...&quot;);    &#125;&#125;\n\n\n这是一个自动配置类，通过 @Bean 注解的 supplyUser() 方法来创建一个 User实例，以实现注入到 Spring 容器中\n\n创建META-INF及spring目录：SpringBoot3 示例接着，在 /main 文件夹下，创建 /resources 包，再创建 /META-INF 文件夹，再在里面创建 /spring 文件夹 , 以及 org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件\n注意，这是自定义 starter 固定步骤，需要严格按照此格式来书写\n如下图：\n.imports 文件中内容如下，填写刚刚的 UserAutoConfiguration自动配置类的完整包路径：\ncom.ze.test.config.UserAutoConfiguration\n\n\nTIP : 创建的 imports 文件，必须保证前面有_小绿叶_标识，如果不是，可能导致自定义 starter 被 IDEA 无法识别的问题：                            \n\n至此，自定义 starter 步骤就完成了，最后的目录结构就是这样\nkid2-spring-boot-starter/├── src/│   ├── main/│   │   ├── java/│   │   │   └── com/ze/test/│   │   │       ├── config/│   │   │       │   └── UserAutoConfiguration.java  # 自动配置类│   │   │       └── user/│   │   │           └── User.java                   # 实体类│   │   └── resources/│   │       └── META-INF/│   │           └── spring/│   │               └── org.springframework.boot.autoconfigure.AutoConfiguration.imports  # 自动配置注册文件│   └── test/│       └── java/                                  └── pom.xml                                       ","categories":["配置"],"tags":["spring"]}]